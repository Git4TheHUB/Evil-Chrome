<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Arena â€“ 2D Fighters (Safe Loader)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  margin: 0;
  overflow: hidden;
  background: #000;
  font-family: Arial, sans-serif;
}

#ui {
  position: absolute;
  top: 10px;
  left: 10px;
  color: white;
  z-index: 10;
}

.bar {
  width: 200px;
  height: 16px;
  background: #333;
  border-radius: 8px;
  overflow: hidden;
  margin-bottom: 10px;
}

.fill {
  height: 100%;
  width: 100%;
  background: linear-gradient(90deg, #44ff44, #88ff88);
  transition: width 0.3s;
}
</style>
</head>

<body>
<div id="ui">
  <div>Player 1</div>
  <div class="bar"><div id="hp1" class="fill"></div></div>
  <div>Author AI</div>
  <div class="bar"><div id="hp2" class="fill"></div></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/* ======================
   CONFIG (EDIT PATHS)
====================== */
const PLAYER_CONFIG = [
  {
    name: "Player 1",
    isAI: false,
    textures: {
      idle: "./assets/player1/idle.png",
      move: "./assets/player1/move.png",
      attack: "./assets/player1/attack.png"
    },
    voice: "./assets/player1/attack.mp3",
    start: { x: -5, z: -5 }
  },
  {
    name: "Author AI",
    isAI: true,
    textures: {
      idle: "./assets/player2/idle.png",
      move: "./assets/player2/move.png",
      attack: "./assets/player2/attack.png"
    },
    voice: "./assets/player2/attack.mp3",
    start: { x: 5, z: 5 }
  }
];

const ARENA_SIZE = 20;
const PLAYER_SPEED = 0.12;
const ATTACK_RANGE = 2.5;
const ATTACK_DAMAGE = 20;
const ATTACK_COOLDOWN = 900;

/* ======================
   THREE SETUP
====================== */
let scene, camera, renderer;
let players = [];
const keys = {};

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x000000, 8, 40);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 12, 14);
  camera.lookAt(0, 0, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.4));

  const light = new THREE.DirectionalLight(0xffffff, 0.8);
  light.position.set(10, 15, 5);
  scene.add(light);

  createArena();
  createPlayers();
  setupInput();
}

/* ======================
   ARENA
====================== */
function createArena() {
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(ARENA_SIZE, ARENA_SIZE),
    new THREE.MeshStandardMaterial({ color: 0x2d4a2d })
  );
  floor.rotation.x = -Math.PI / 2;
  scene.add(floor);
}

/* ======================
   SAFE LOADERS
====================== */
const texLoader = new THREE.TextureLoader();
const audioListener = new THREE.AudioListener();
camera.add(audioListener);

window.addEventListener("click", () => {
  audioListener.context.resume();
}, { once: true });

function makeFallbackTexture(color = "magenta") {
  const c = document.createElement("canvas");
  c.width = 64;
  c.height = 128;
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,64,128);
  ctx.fillStyle = color;
  ctx.fillRect(0,0,64,128);
  return new THREE.CanvasTexture(c);
}

function loadTextureSafe(path, fallback) {
  return new Promise(resolve => {
    texLoader.load(
      path,
      tex => {
        tex.transparent = true;
        tex.premultiplyAlpha = true;
        resolve(tex);
      },
      undefined,
      () => resolve(fallback)
    );
  });
}

function loadAudioSafe(path) {
  return new Promise(resolve => {
    const audio = new THREE.Audio(audioListener);
    new THREE.AudioLoader().load(
      path,
      buffer => {
        audio.setBuffer(buffer);
        audio.setVolume(0.6);
        resolve(audio);
      },
      undefined,
      () => resolve(audio)
    );
  });
}

/* ======================
   PLAYERS
====================== */
async function createPlayers() {
  for (const cfg of PLAYER_CONFIG) {

    const fallback = makeFallbackTexture(cfg.isAI ? "blue" : "red");

    const textures = {
      idle: await loadTextureSafe(cfg.textures.idle, fallback),
      move: await loadTextureSafe(cfg.textures.move, fallback),
      attack: await loadTextureSafe(cfg.textures.attack, fallback)
    };

    const material = new THREE.SpriteMaterial({
      map: textures.idle,
      transparent: true,
      depthWrite: false
    });

    const sprite = new THREE.Sprite(material);
    sprite.scale.set(2, 3, 1);
    sprite.position.set(cfg.start.x, 1.5, cfg.start.z);
    scene.add(sprite);

    const sound = await loadAudioSafe(cfg.voice);

    players.push({
      sprite,
      textures,
      sound,
      health: 100,
      lastAttack: 0,
      attacking: false,
      isAI: cfg.isAI,
      velocity: new THREE.Vector3()
    });
  }
}

/* ======================
   INPUT
====================== */
function setupInput() {
  window.addEventListener("keydown", e => keys[e.code] = true);
  window.addEventListener("keyup", e => keys[e.code] = false);
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

/* ======================
   GAME LOGIC
====================== */
function setTexture(p, type) {
  p.sprite.material.map = p.textures[type];
  p.sprite.material.needsUpdate = true;
}

function attack(i) {
  const a = players[i];
  const d = players[1 - i];
  const now = Date.now();

  if (now - a.lastAttack < ATTACK_COOLDOWN) return;

  a.lastAttack = now;
  a.attacking = true;
  setTexture(a, "attack");

  if (a.sound && a.sound.buffer) {
    if (a.sound.isPlaying) a.sound.stop();
    a.sound.play();
  }

  if (a.sprite.position.distanceTo(d.sprite.position) <= ATTACK_RANGE) {
    d.health = Math.max(0, d.health - ATTACK_DAMAGE);
    updateHP();
  }

  setTimeout(() => {
    a.attacking = false;
    setTexture(a, "idle");
  }, 300);
}

function updateHP() {
  document.getElementById("hp1").style.width = players[0].health + "%";
  document.getElementById("hp2").style.width = players[1].health + "%";
}

function updatePlayer(i) {
  const p = players[i];
  p.velocity.set(0, 0, 0);

  if (!p.isAI) {
    if (keys["KeyW"]) p.velocity.z -= PLAYER_SPEED;
    if (keys["KeyS"]) p.velocity.z += PLAYER_SPEED;
    if (keys["KeyA"]) p.velocity.x -= PLAYER_SPEED;
    if (keys["KeyD"]) p.velocity.x += PLAYER_SPEED;
    if (keys["Space"]) attack(i);
  }

  if (p.velocity.length() > 0) {
    p.sprite.position.add(p.velocity);
    if (!p.attacking) setTexture(p, "move");
  } else if (!p.attacking) {
    setTexture(p, "idle");
  }

  p.sprite.lookAt(camera.position);
}

/* ======================
   AI
====================== */
function updateAI(i) {
  const ai = players[i];
  const target = players[0];

  const dir = new THREE.Vector3().subVectors(
    target.sprite.position,
    ai.sprite.position
  );

  const dist = dir.length();
  dir.normalize();

  if (dist > 2.3) {
    ai.sprite.position.add(dir.multiplyScalar(PLAYER_SPEED * 0.8));
    if (!ai.attacking) setTexture(ai, "move");
  } else {
    attack(i);
  }

  ai.sprite.lookAt(camera.position);
}

/* ======================
   LOOP
====================== */
function animate() {
  requestAnimationFrame(animate);

  if (players.length === 2) {
    players.forEach((p, i) => {
      if (p.isAI) updateAI(i);
      updatePlayer(i);
    });
  }

  renderer.render(scene, camera);
}
</script>
</body>
</html>
